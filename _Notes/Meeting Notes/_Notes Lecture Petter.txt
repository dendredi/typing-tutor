Video 42: Intro

- Variable declaration/use Analysis
- Shadowing (overwriting variable names in nested scopes)

-----------------------------------------------------------------------------
Video 43: String hashing

- Main idea: Instead of using strings as variables, lets have unique integers instead
- Algorithm: "Replace strings with integers" (hashtable string->int)
	* Input: sequence of strings
	* Output: sequence of numbers; table that allows to retrieve the string from the number
	
	let map: Map<string, number> = new Map();
	let count = 0;

	indexForIdentifier(w: string): number {
		const val = map.get(w);
		if(!val){
			map.set(w, count);
			return count++;
		}else {
			return val;
		}
	}
(* Algorithms covered in lecture)

-----------------------------------------------------------------------------
Video 44: Refer Use to Declarations: Symbol Tables
- Input: Declaration labels replaced by IDs (by Scanner, Video 43)
- AST should be traversable, so that
	* each declaration is visited before its uses
	* currently visible declaration is the last one visited ("scopes von innen nach auÃŸen")
	--> perfect: L-attributed grammar
- For each identifier (label), we manage a stack of its declarations (= Table of stacks)
	(* more elegang: persistent trees)
- Hint: Implementation details in end of video
-----------------------------------------------------------------------------
Video 45: Type Checking

- Goal of type checking: manage memory, select correct assembler instructions (e.g. mult for float vs int), avoid runtime errors
- Types are defined at variable declaration. Compiler then checks for a type correct use (function calls, operators, ...)
- Type is not changed anymore (except of shadowing)
- Type in declaration is given by type expression
	* base types: int, char, float void
	* type constructors --> compose bigger types containing base types, e.g. structs, pointers, arrays, functions,
- Type Checking (Problem Def.)
	* Given: Set of type declarations {t_1 x_1, ..., t_n x_n}
	* Check: Can an expression e be given a type t / Is e correctly typed
	(* Example: see 7:20)
- Algorithm - Idea:
	* traverse AST bottom up
	* for each identifier look up type (from declarations / "typing environment")
		--> At leafs: constants with fixed types (e.g. 1 -> int, 'c' -> char, ...)
		--> Inner nodes: Types deduced using typing rules
- Subtyping relation t_2 <= t_1: "t_1 needs to cover at least everything that is covered by t_2" / "t_1 needs to be a superset of t_2"


-----------------------------------------------------------------------------
Video 46: Beispiel Type Checking

-----------------------------------------------------------------------------
Video 47: 

- Summary Type Checking: Choosing which rule to apply at an AST node is determined by the type of the child nodes
- Type equality - recursive check with rules:
	(* struct A {...} and struct B {...} are condidered to be different)
	* typedef int C --> types int and C are equal
	* s* and t* are equal <--> s and t are equal
	* A == t <--> typedef A t or typedef t A
	* struct {s1 a1; ... sm am;} and struct {t1 a1; ... tm am;} <--> s1 = t1, ..., sm = tm
	* Note: Loops in recursive type equivalence queries (found one equal string pair) without contradiction means STRUCTURAL EQUIVALENCE  
- Structural Type Equality (NOT holding in C!) 
	* t1 and t2 are equal if they accep the same set of access paths
	* means some work in other systems than C
- 
-----------------------------------------------------------------------------
Video 48: Subtyping

- Rules for simple subtypeing: t1 <= t2 means that the values of type t1:
	* form a subset of the values of type t2
	* can be converted into a value of type t2
	* fulfill the requirements of type t2
	* are assignable to variables of type t2
- Example: int x; double y; y = x; --> int <= double
- Rules for composite subtyping (e.g. for structs, functions; --> "extractInfo" example in lecture):
	* t <= t' <--> t <= t'
	* s* <= t* <--> s <= t
	* A <= t  <--> typedef A t or typedef t A
	* struct {s_1 a_1; ... s_j a_j;} <= struct {t_1 a_1; ... t_k a_k;} <--> s_1 <= t_1, ..., s_k <= t_k (Note: may have different # of accessors as long as j >= k) 
	* s_0 (s_1, ..., s_m) <= t_0 (t_1, ..., t_m) <--> s_0 <= t_0 && t_1 <= s_1, ..., t_m <= s_m (Note: reversed order in parameter types!) --> co- and contra-variance of return type and arguments
- Note: In JAVA, subtyping is explicitly declared instead of being infered by the compiler

__________________________________________________________
Questions:

- Subtype checking: why is rule for function params reversed?
- further literature for work?