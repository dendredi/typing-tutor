1. Decisions at project kick off
	- Agular: Webfrontend framework, types (TS), 
	- Docker: Plattformagnostic, easy/clean dployment
	- CI/CD pipeline with with test server hosted on AWS --> better and faster feedback from chair
		* branch model
	
2. External Project Dependencies
	- Code editor
		* https://ace.c9.io/ (no suitable angular wrapper) // TODO Probably not relevant
		* monaco code editor / ngx-monaco-editor
			--> Includes:
				* Code highlighting support for various languages
				* Undo-Redo-Stack
			--> Micorsoft: 		https://microsoft.github.io/monaco-editor/
			--> Angular wrapper: 	https://www.npmjs.com/package/ngx-monaco-editor
	- Lexer and Parser
		* node-c-parse https://www.npmjs.com/package/node-c-parser
			--> Dependenys indluce
				- child_process
				- fs
				- readline (reading data from a Readable stream, e.g. porcess.stdin, see: https://nodejs.org/api/readline.html#readline)
			--> library supposed to run in node backend process
			--> Client-Server-Architecture needed (without mayor overhead of providing "adapter" environment)
		* cparse: https://github.com/M4GNV5/cparse
			--> fast (maybe compare?)
			--> Client-only-approach posible (maybe compare with work of leo fahrbach)
			--> easy to adopt

3. Journal

	- Session 1
		* Analysing output of cparse; Creating Types for relevant AstNodes
		* graph lib (TODO: note above in 2.)
		* extend AstNodes with graph generation functionality
	- Session 2
		* ...
	- Session 3 (26.11.2021)
		* Re-watch videos
		* new subsystem: typing
		* class TypeEnvironment including axioms and rules
		* ideas about integration of "typing" and "ast" --> interface TypeCheckable
	- Session 4 (29.11.2021)
		Video 46
		* App-Concept (according to video 46): TypeChecking visualization subdivided into (at least) two phases:
			1. Structural decomposition phase
				- Recursive forward propagation phase
				- until leafs --> here: lookup respective types for variables / determine natural types for constants
			2. Backpropagation phase
				- check for any rule that can be discharged to optain type
				- accumulate resulting type for whole expression
		* Open: What to do with subtyping ('=<')
		
	- Session 5 (30.11.2021)
		* Question: where to get declarations from? shadowning? (--> video 44)
		* SymbolTable Implementation
			* Interface "Declaration" for AST-Nodes --> delegate getType() and getIdentifier (this way, also obtain code line)
			* Idea of persistent tables --> "snapshots"
	
	- Session 10.12.2021
		* App UX: link code and ast via lineNumber in AstNode	
			--> Click node -> highlight code; click code -> highlight node
			--> highlight code on errors
	
	- Session 12.12.2021
		* Implementation of typing tree GUI
			--> class TypingTree
			--> recursive angular component
			--> css display: flex, margin-top: auto
			--> Idea: Implement history in typingtree class --> back-forward-reset buttons
			--> Problems: in each recursion step, uniformly split available space per child node without respect to really needed space
				--> in very unbalanced trees this costs a lot of unnessesary space --> bad UX (see screenshot!)
				--> Solution ideas: somehow pay attention to needed space per child --> rec method for calculation
	- Session 18.01.2022
		* Implementation of aggregate initialization
			--> structs
			
			struct T {
				int x;
				char c;
			}
			struct T t = { .x = 42, .c = "C"};#
Log from parser:

defType: {type: 'Type', modifier: Array(1), pos: {…}, name: 'T'}
name: "t"
pos: {file: 'unknown', line: 7}
type: "VariableDeclaration"
value:
pos: {file: 'unknown', line: 7}
type: "Literal"
value: Array(2)
0:
left: {type: 'BinaryExpression', operator: '.', left: undefined, right: {…}, pos: {…}}
operator: "="
pos: {file: 'unknown', line: 7}
right: {type: 'Literal', value: 3, pos: {…}}
type: "BinaryExpression"
[[Prototype]]: Object
1:
left: {type: 'BinaryExpression', operator: '.', left: undefined, right: {…}, pos: {…}}
operator: "="
pos: {file: 'unknown', line: 7}
right: {type: 'Literal', value: 'C', pos: {…}}
type: "BinaryExpression"
[[Prototype]]: Object
length: 2
[[Prototype]]: Array(0)
[[Prototype]]: Object
[[Prototype]]: Object


			--> arrays
			int xs[3] = {1, 2, 3};
Log from parser:

defType:
pos: {file: 'unknown', line: 3}
target: {type: 'Type', modifier: Array(0), pos: {…}, name: 'int'}
type: "PointerType"
[[Prototype]]: Object
name: "xs"
pos: {file: 'unknown', line: 3}
type: "VariableDeclaration"
value:
pos: {file: 'unknown', line: 3}
type: "Literal"
value: Array(3)
0: {type: 'Literal', value: 1, pos: {…}}
1: {type: 'Literal', value: 2, pos: {…}}
2: {type: 'Literal', value: 3, pos: {…}}
length: 3
[[Prototype]]: Array(0)
[[Prototype]]: Object
[[Prototype]]: Object
		
		--> Implement both in "AggregateInitialization"-AstNode (git commit before: "Implement SymbolTable UI")
		--> http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf (137)

	- Session 19.01.2022
		--> Special treatment of BinaryExpression: tranlate "a->b" to "(*a).b"
 

__________
Additional notes / Ideas:

- Prerequisites Angular (Directives, ...) --> Refer back later in work; TypeScript get set
- UndoRedoStack (Ref. BA)
- Use Template Methode pattern, if e.g. performTypeCheck and getTypingTree will be merged (also additional steps if e.g. typing tree history idea will be implemented; typeEnvironment modifications?)
- Another major refactoring: allow variable declarations without initialization (underlying parser does not support; dynamic vs static typing; )
- Idea to extend work: Implement config with "Enable Dynamic/static typecheck"
- Decorators: Basic concept, decorators in typescript (maybe python as comparison), example in code: storeError (or different)
	--> Go into detail for extending type-error integration into typing tree
		* decorators (see above)
		* subclass of Typing-Tree --> ErrorTypingTree
		* event better: Use decorators for whole history feature
		* ("Aspect oriented programming")
- Refactoring
	* devide AbstractAstNode into two subtypes: ExpressionNode (with type = NotVisitedPlaceholder) and SyntaxNode (with type = NoTypePlaceholder; think of better name)