A. Intro: Goal of the Project
	* Goal of Typing in general (e.g.: manage memory, select correct assembler instruction, avoid certain run-time errors)
	* Goal of Tool: Webtool to enable visually accompanied learning/understanding of Typing and Structural Subtyping
	
B. Theoretical Fundamentals: Explanation of Algorithms for
	* Typing 
		- Problem definition
		- Type expressions (Set of base types and type constructors)
		- Type environment, Set of typing rules
		- example
		(- Symbol tables?)
	* Structural Subtyping
		- Problem definition (including Definition/Meaning)
		- Role in this project (teaching purpose only; actually not covered by C (nominal type systems), but still important concept for languages like e.g. TypeScript)
		- Supplement to typing rules: "can be converted to"/"can be assigned to"
		- Set of deduction rules (Explain detail: co- and contra-variance in rule for functions - example: array function map)
		- example

C. Technical Decisions / TechStack
	(
		* Framework / Language
		- TypeScript
			- superset of javascript implementing type system and OOP concepts 
			- Decorators (Purpose, variants, math concat explanation)
			(- override and the --noImplicitOverride Flag)
        - Angular Basics
			- core principals (component-based frontend framework, ...)
			- directive examples
			(- change detection)
		- RxJS (e.g. component-interconnection-service)
	* Dependencies (e.g. monaco-code-editor, apache echart, cparse, cdecl.org) 
	)
	* High-level model - Class Diagram (Ast, Types, TypeEnvironment, ... )

D. Webtool structure and development process
	* TypeConstructionKitComponent
		- Problem: User Input only by code-editor (first approach), BUT: Incapability of 'cparse' handling complex types and Typedefs
		(example: Nested structs, functions as parameters, typedefs for structs) 
		- Solution:
			- provide base types as atomic building blocks
			- type constructor templates as toolset for consecutive type construction
			- output: larger set of types + Typdefs and Declarations (printed in readonly code-editor)
		- Implementation:
			- Lifecycle-hooks of AbstractTypeBubble as a framework enabling extension (provide UML Class Diagram!)
			(- State Pattern)
			- AliasPlaceholder as workaround for recursive typedefs (provide example use case)
		- Cdecl
			- Explanation with example why it is required
			- Webservice NOT suitable due to lack of structs. Also no workaround possible (e.g. [complex pointer/array combo] to pointer to struct)
			- However, webservice still useful for testing --> Test driven development
	* Tab "Typing"
		- UI / Manual
			- Input field for expression (based on output of TypeConstructionKitComponent)
		 	- Visualizing entered expression with AST by apache echarts
			- TypingTreeComponent on the right side
		- TypingTreeComponent
			- Recursive Angular component
			- Display space allocation by (recursively computed) node width depending on number of children (show screenshots before and after)
		- Implementation of the Algorithm
			- Mapping typing rules to performTypeCheck() implementations of AstNode subclasses (one rule as example)
				- ambiguous type with binop --> specify!
				- failWithTypeError() --> recovery strategy (Clear: strategy 'expected' and 'wildcard')
				- TODO: PROVIDE FULL GRAINED SPECIFICATION OF WHAT DECISIONS ARE MADE REGARDING TYPING IN EXCEPTINOAL/EDGE CASES
	* Tab "Structural Subtyping"
		- UI / Manual
			- Dropdowns for selection of two types (from output of TypeConstructionKitComponent)
			- Visualization of structural subtyping query via graph on the right
		- Implementation of the Algorithm
			- Template Method Pattern
				- decomposing complex tasks into smaller steps
				- allowing slight changes by substitution of only relevant steps without rewriting unaffected logic 
			- Nested Template Method Pattern in AbstractType
				- isStrutcturalSubtypeOf
					- performStructuralSubtypingCheck
						- manageQueryHistory, checkEquality, checkRealSubtypingRelation (+ steps writing buffer)
					- buildQueryGraph
						- buildBasicGraph, handleLoop, extendGraph, handleCaseOtherBeingAlias (+ steps reading buffer)
					- Communication between two procedures via: structuralSubtypingBuffer: Queue<StructuralSubtypingBufferFrame>
			- Mapping deduction rules to implementations of checkRealSubtypingRelation-steps in AbstractType subtypes (expample in e.g. FunctionType) 

E. Outlook
	* Replayable History for TypingTree and SubtypingGraph (e.g. using Decorators to avoid changing existing code)
	* Configuration store (localstorage, serialize/deserialize) persisting constructed types etc.
	* Add Tab with code editor (with multiple lines) and finish Symbol table



_________________________________________________________
Not yet positioned:

* (Explanation of some of the applied design patterns
	- Callback Pattern
	- Template Method Pattern
	- State Pattern)

- "Structural Subtyping"
	* Theory
		- Part 1: (Structural) Type Equality (Note: "equality is subset of subtyping") (Note: for previous features; equals was just easy string comp for testing purpose)
		- Part 2: (Structural) Subtyping (e.g. co- and contra-variance of subtyping of functions -> explanation with subsets)
	* Proof of termination

- New Feature: typedefs
	* Add AstNode "TypeDefStatement"
	* Add placeholder-type for it only containing name (reference to targte type would break recursion)
	* Refactor: Add Typedefs to TypeEnvironment (idea: refactor to context holding all entities?)
	* Refactor: Add Typedefs as parameter to AbstractType::isStrutcturalSubtypeOf

- Low Coupling/High Cohesion
	* Theory (slides EIST, PSE)
	* Subsystems 'typing' and 'ast'
	* Callback pattern with dedicated interfaces


- Transition Plan to Actual Tool
	* Explain basic idea (only code editor as input covering all required features)
	* Problems of cparse --> input boundaries / problems leading to bad UX
	* type-construction-kit.component
		- Explain lifecycle (e.g. on one example component. Maybe one difficult and one simple)
	* For typecheck two alternatives:
		- use existing parser and write adapter to translate input to "code with bad UI"
		- implement simple parser for expressions 
	* do not use symbol table etc
	* type-construction-kit.component
		- Add Typedef, declaration action on bubbles
		- Make recursive structs work:
			1. Add alias placeholder bubble with every typedef
			2. Add feature to add alias placeholder bubble without acutal Typedef (--> can use it in struct creation)
			3. Add actual typedef afterwards
			4. Invariance: Every typedef comes with its placeholder && placeholders are unique
				-   @Input("isAliasAvailableCallback") isAliasAvailableCallback: (alias: string) => boolean;
				-	private addTypedef(alias: string, type: AbstractType): void {...} --> always checking if there is already a suitable placeholder
				- 	Goal: Placeholders either already defined, or will be soon (-->exception to enable recursiveness)


C. (DEPRECATED) Development Progress (Typing; chronologisch)
	* Baseline: Integration of monaco, cparse and echarts
	* Adding TypeEnvironment / Symbol Table
	* Adding performTypeCheck() (isSubtypeOf 'mocked' by equals())
	* Vizualization of Typing by TypingTree
		- Type placeholder to always have full typing tree
		- Enhanced display size allocation by node width depending on number of children (add screenshots before/after)

URLS

* Decorators
	https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators
	https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition