A. Goal (and blueprint) of the Tool
	* Goal of Typing (see screenshots, e.g.: manage memory, select correct assembler instruction, avoid certain run-time errors)
	* Goal of Tool (lerning by vizualization of ... a) Typing b) Structural Subtyping

B. Technical Decisions / Fundamentals
	* Framework / Language
		- TypeScript (override and the --noImplicitOverride Flag)
			- Decorators (Purpose, variants, math concat explanation)
        - Angular Basics (directive examples, change detection)
	* Dependencies (e.g. monaco-code-editor, apache echart, cparse)
	* Class Diagram (AstNode, TypeExpression, TypeEnvironment... )
	* (Explanation of some of the applied design patterns
		- Callback Pattern
		- Template Method Pattern
		- State Pattern)

C. Development Progress
    * New Features
	- Baseline: Integration of monaco, cparse and echarts (Realtime refresh by angular change detection)
	- Adding TypeEnvironment / Symbol Table
	- Adding performTypeCheck()
	- Vizualization by Typing tree (also: add type placeholder to always have full typing tree)
    * Refactorings (Abstractions etc.)
        - Better display size allocation for TypingTree visualization (Add node width depending on number of children; add screenshots)
D. Outlook
	* Proxy Pattern for cdecl calls
	* Typing Tree History
	* Configuration store (localstorage, serialize/deserialize)

_________________________________________________________
Not yet positioned:

- Ideas:
	* Replayable TypingTree- and Symbol Table-History (using Decorators)

- "Structural Subtyping"
	* Theory
		- Part 1: (Structural) Type Equality (Note: "equality is subset of subtyping") (Node: for previous features; equals was just easy string comp for testing purpose) (Note: does not hold in C)
		- Part 2: (Structural) Subtyping (e.g. co- and contra-variance of subtyping of functions -> explanation with subsets)
	* Proof of termination
	* Implementation in project
		- order of decorators! (see math concat from B.)
- New Featur: typedefs
	* Add AstNode "TypeDefStatement"
	* Add placeholder-type for it only containing name (reference to targte type would break recursion)
	* Refactor: Add Typedefs to TypeEnvironment (idea: refactor to context holding all entities?)
	* Refactor: Add Typedefs as parameter to AbstractType::isStrutcturalSubtypeOf

- Low Coupling/High Cohesion
	* Theory (slides EIST, PSE)
	* Subsystems 'typing' and 'ast'
	* Callback pattern with dedicated interfaces
- User Experience
	* Only show AST of selected row (with cursor)?
	* 

- URLs for decorators
	* https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators
	* https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition


- Transition Plan to Actual Tool
	* Explain basic idea (only code editor as input covering all required features)
	* Problems of cparse --> input boundaries / problems leading to bad UX
	* type-construction-kit.component
		- Explain lifecycle (e.g. on one example component. Maybe one difficult and one simple)
	* For typecheck two alternatives:
		- use existing parser and write adapter to translate input to "code with bad UI"
		- implement simple parser for expressions 
	* do not use symbol table etc
	* type-construction-kit.component
		- Add Typedef, declaration action on bubbles
		- Make recursive structs work:
			1. Add alias placeholder bubble with every typedef
			2. Add feature to add alias placeholder bubble without acutal Typedef (--> can use it in struct creation)
			3. Add actual typedef afterwards
			4. Invariance: Every typedef comes with its placeholder && placeholders are unique
				-   @Input("isAliasAvailableCallback") isAliasAvailableCallback: (alias: string) => boolean;
				-	private addTypedef(alias: string, type: AbstractType): void {...} --> always checking if there is already a suitable placeholder
				- 	Goal: Placeholders either already defined, or will be soon (-->exception to enable recursiveness)


